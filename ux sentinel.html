<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>UX_SENTINEL: V20.0 [ZENITH]</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&family=Rajdhani:wght@600;700&display=swap" rel="stylesheet">

    <style>
        /* * ==========================================================================
         * CORE AESTHETICS (Professional Dark Mode - V20.0)
         * ==========================================================================
         */
        :root {
            --bg-dark: #090a0c;
            --panel-bg: #111418;
            --panel-border: #2d333b;
            
            /* SYNTAX HIGHLIGHTING COLORS */
            --accent-blue: #58a6ff;
            --accent-red: #ff7b72;
            --accent-green: #3fb950;
            --accent-orange: #d29922;
            --accent-purple: #bc8cff; /* Gaze */
            --accent-gold: #d2a8ff;   /* OCR */
            --accent-cyan: #39c5bb;   /* DOM */
            --accent-pink: #ff79c6;   /* AI Architect */
            --accent-neon: #00f0ff;   /* Replay/Phantom */
            
            --text-main: #f0f6fc;
            --text-dim: #8b949e;
            
            --font-ui: 'Inter', sans-serif;
            --font-code: 'JetBrains Mono', monospace;
            --font-tech: 'Rajdhani', sans-serif;
        }

        * { box-sizing: border-box; scrollbar-width: thin; scrollbar-color: var(--panel-border) var(--bg-dark); }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: var(--font-ui);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- HEADER --- */
        header {
            height: 60px;
            border-bottom: 1px solid var(--panel-border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
            background: var(--panel-bg);
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .brand {
            font-family: var(--font-tech);
            font-weight: 700;
            font-size: 24px;
            color: var(--accent-gold);
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 12px;
            text-shadow: 0 0 10px rgba(210, 168, 255, 0.3);
        }

        .status-badge {
            background: #0d1117;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: var(--font-code);
            border: 1px solid var(--panel-border);
            min-width: 180px;
            text-align: center;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        /* Dynamic Status States */
        .status-badge.active { border-color: var(--accent-green); color: var(--accent-green); box-shadow: 0 0 10px rgba(63, 185, 80, 0.2); }
        .status-badge.error { border-color: var(--accent-red); color: var(--accent-red); }
        .status-badge.analyzing { border-color: var(--accent-orange); color: var(--accent-orange); animation: pulse 1s infinite; }
        .status-badge.mobile { border-color: var(--accent-blue); color: var(--accent-blue); }
        .status-badge.ocr { border-color: var(--accent-gold); color: var(--accent-gold); animation: pulse-fast 0.5s infinite; }
        .status-badge.calib { border-color: var(--accent-purple); color: var(--accent-purple); }
        .status-badge.dom { border-color: var(--accent-cyan); color: var(--accent-cyan); background: rgba(57, 197, 187, 0.05); }
        .status-badge.ai { border-color: var(--accent-pink); color: var(--accent-pink); background: rgba(255, 121, 198, 0.1); }
        .status-badge.replay { border-color: var(--accent-neon); color: var(--accent-neon); background: rgba(0, 240, 255, 0.1); box-shadow: 0 0 15px rgba(0,240,255,0.2); }
        .status-badge.fallback { border-color: var(--accent-orange); color: var(--accent-orange); border-style: dashed; }
        .status-badge.phantom { border-color: var(--accent-neon); color: var(--bg-dark); background: var(--accent-neon); font-weight: 800; animation: pulse-fast 1s infinite; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        @keyframes pulse-fast { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }

        /* --- MAIN LAYOUT --- */
        main {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 350px; 
            gap: 0;
            height: calc(100vh - 60px);
        }

        /* LEFT COLUMN (VISUALS) */
        #visual-column {
            position: relative;
            background: #0d1117;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--panel-border);
        }

        /* SCREEN CONTAINER */
        #screen-panel {
            flex: 2;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background-image: radial-gradient(#1f2428 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #screen-video, #mobile-sim-img {
            max-width: 95%;
            max-height: 95%;
            border: 1px solid var(--panel-border);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            display: none;
        }
        
        #screen-video.active, #mobile-sim-img.active { display: block; }

        /* OVERLAYS */
        #dom-overlay, #heatmap-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
        #dom-overlay { z-index: 15; }
        #heatmap-canvas { z-index: 20; mix-blend-mode: screen; }

        /* PHASE 22: RING LIGHT OVERLAY */
        #ring-light {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.9);
            z-index: 5000;
            display: none;
            pointer-events: none; /* Let clicks pass through */
            mix-blend-mode: overlay;
        }

        /* PHASE 20: ENV WARNING HUD */
        #env-warning {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 123, 114, 0.9);
            color: #fff;
            padding: 8px 16px;
            border-radius: 4px;
            font-family: var(--font-code);
            font-size: 12px;
            z-index: 50;
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #ff0000;
            animation: pulse 1s infinite;
        }

        /* PHASE 11: RE-CENTER TARGET */
        #recenter-target {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 40px; height: 40px;
            border: 2px solid var(--accent-green);
            border-radius: 50%;
            display: none;
            z-index: 50;
            cursor: pointer;
            background: rgba(0, 255, 0, 0.1);
            align-items: center; justify-content: center;
            color: var(--accent-green); font-size: 20px;
            transition: all 0.2s;
        }
        #recenter-target:hover { background: rgba(0, 255, 0, 0.3); transform: translate(-50%, -50%) scale(1.1); }

        /* WEBCAM PIP */
        #face-pip {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: #000;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            overflow: hidden;
            z-index: 50;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }

        #face-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }
        #face-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* RIGHT COLUMN (DATA) */
        aside {
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* PHASE 8: AI CONSOLE */
        #ai-console {
            height: 220px;
            background: #0d1117;
            border-bottom: 1px solid var(--panel-border);
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .console-header {
            font-family: var(--font-code);
            font-size: 11px;
            color: var(--accent-pink);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }

        #ai-output {
            flex: 1;
            font-family: var(--font-code);
            font-size: 11px;
            color: var(--text-main);
            line-height: 1.6;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .ai-cursor { display: inline-block; width: 6px; height: 12px; background: var(--accent-pink); animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* METRICS */
        #metrics-panel {
            padding: 20px;
            border-bottom: 1px solid var(--panel-border);
        }

        .metric-row {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;
            font-family: var(--font-code); font-size: 10px; color: var(--text-dim);
        }

        .bar-bg { flex: 1; height: 4px; background: #21262d; margin-left: 10px; border-radius: 2px; overflow: hidden; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.2s; }

        /* LOGS */
        #log-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-title {
            padding: 10px 15px;
            font-size: 10px;
            font-weight: 700;
            color: var(--text-dim);
            text-transform: uppercase;
            border-bottom: 1px solid var(--panel-border);
            background: rgba(0,0,0,0.2);
        }

        #log-feed {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: var(--font-code);
            font-size: 10px;
        }

        .log-entry { margin-bottom: 6px; padding-left: 8px; border-left: 2px solid transparent; opacity: 0.8; }
        .log-entry:hover { opacity: 1; background: rgba(255,255,255,0.02); }
        
        .log-entry.alert { border-color: var(--accent-red); color: #ffadba; }
        .log-entry.gaze { border-color: var(--accent-purple); color: #d8b9ff; } 
        .log-entry.ocr { border-color: var(--accent-gold); color: #ffeeb0; } 
        .log-entry.dom { border-color: var(--accent-cyan); color: #b4f0e8; } 
        .log-entry.ai { border-color: var(--accent-pink); color: #ffcce6; font-weight: bold; }
        .log-entry.sys { border-color: var(--accent-blue); color: #79c0ff; }
        .log-entry.phantom { border-color: var(--accent-neon); color: var(--accent-neon); font-weight:bold; }

        /* GALLERY */
        #snapshot-gallery {
            height: 120px;
            padding: 10px;
            border-top: 1px solid var(--panel-border);
            background: #0d1117;
            display: flex;
            gap: 10px;
            overflow-x: auto;
        }

        .snapshot {
            height: 100%; aspect-ratio: 16/9;
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .snapshot:hover { border-color: var(--accent-pink); transform: translateY(-2px); }
        .snapshot img { width: 100%; height: 100%; object-fit: cover; }
        .snap-badge {
            position: absolute; top: 4px; right: 4px;
            background: rgba(0,0,0,0.8); color: var(--accent-pink);
            font-size: 8px; padding: 2px 4px; border-radius: 2px;
            font-family: var(--font-code); border: 1px solid var(--accent-pink);
        }

        /* --- CONTROLS --- */
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 100;
            background: rgba(17, 20, 24, 0.9); padding: 10px; border-radius: 12px;
            border: 1px solid var(--panel-border);
            backdrop-filter: blur(10px);
        }

        .btn {
            background: #21262d; color: var(--text-main);
            border: 1px solid var(--panel-border);
            padding: 10px 20px; border-radius: 6px;
            font-weight: 600; font-size: 12px;
            cursor: pointer; font-family: var(--font-ui);
            transition: all 0.2s; display: flex; align-items: center; gap: 8px;
        }

        .btn:hover { background: #30363d; border-color: var(--text-dim); }
        .btn.primary { background: var(--accent-blue); color: #000; border-color: transparent; }
        .btn.stop { background: var(--accent-red); color: #fff; border-color: transparent; }
        .btn.ai { background: var(--accent-pink); color: #000; border-color: transparent; }
        .btn.upload { background: var(--accent-cyan); color: #000; border-color: transparent; }
        .btn.replay { background: var(--accent-neon); color: #000; border-color: transparent; }
        .btn.tool { background: var(--accent-orange); color: #000; border-color: transparent; }

        /* CALIBRATION OVERLAY */
        #calib-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(9, 10, 12, 0.98); z-index: 2000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .calib-dot {
            width: 24px; height: 24px; background: var(--accent-red);
            border-radius: 50%; position: absolute; cursor: pointer;
            box-shadow: 0 0 20px var(--accent-red);
            transition: all 0.3s;
        }
        .calib-dot:hover { transform: scale(1.5); background: #fff; }

        /* PHASE 16: PHANTOM LINK HOST OVERLAY */
        #phantom-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(9, 10, 12, 0.98); z-index: 3000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #qrcode-container { padding: 20px; background: #fff; border-radius: 12px; margin-bottom: 20px; }
        .phantom-text { font-family: 'Rajdhani'; font-size: 24px; color: var(--accent-neon); margin-bottom: 10px; }
        .phantom-sub { font-family: 'Inter'; color: var(--text-dim); font-size: 14px; text-align: center; max-width: 400px; }

        /* PHASE 16: SENSOR MODE (MOBILE) */
        #sensor-ui {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 4000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .sensor-pulse {
            width: 100px; height: 100px; border-radius: 50%;
            background: var(--accent-neon);
            animation: pulse-fast 1s infinite;
            box-shadow: 0 0 50px var(--accent-neon);
        }

        /* PHASE 10: SUMMARY OVERLAY */
        #summary-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(9, 10, 12, 0.95); z-index: 3000;
            display: none; align-items: center; justify-content: center;
        }
        .summary-card {
            width: 600px; background: #161b22; border: 1px solid var(--panel-border);
            border-radius: 12px; padding: 30px; box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        .summary-title { font-family: var(--font-tech); font-size: 28px; color: var(--text-main); margin-bottom: 20px; border-bottom: 1px solid var(--panel-border); padding-bottom: 10px; }
        .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .stat-item { background: #0d1117; padding: 15px; border-radius: 8px; border: 1px solid var(--panel-border); }
        .stat-val { font-size: 24px; font-weight: bold; color: var(--accent-blue); }
        .stat-label { font-size: 12px; color: var(--text-dim); }

        /* PHASE 15: HIGHLIGHT REEL */
        #highlight-reel {
            margin-top: 15px;
            display: flex; gap: 10px;
            overflow-x: auto;
            padding-bottom: 10px;
        }
        .highlight-chip {
            background: rgba(255, 123, 114, 0.1);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 10px;
            font-family: var(--font-code);
            cursor: pointer;
            white-space: nowrap;
        }
        .highlight-chip:hover { background: var(--accent-red); color: #fff; }

        /* HIDDEN ELEMENTS */
        .hidden { display: none !important; }
        canvas.proc { display: none; }

        /* MOBILE FIX */
        @media (max-width: 768px) {
            main { grid-template-columns: 1fr; grid-template-rows: 1fr 1fr; }
            #screen-panel { height: 300px; }
            aside { height: 100%; }
            #face-pip { width: 100px; height: 75px; bottom: 10px; right: 10px; }
        }

    </style>
</head>
<body>

    <header>
        <div class="brand">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                <path d="M2 12h20"/>
            </svg>
            UX_SENTINEL <span style="font-weight:400; color:var(--text-dim); font-size:14px;">// V20.0 ZENITH</span>
        </div>
        <div class="status-badge" id="sys-status">SYSTEM: IDLE</div>
    </header>

    <div id="ring-light"></div>

    <div id="calib-overlay">
        <h2 style="color:#fff; font-family:'Rajdhani'; margin-bottom:20px;">OCULAR CALIBRATION SEQUENCE</h2>
        <p style="color:var(--text-dim); font-family:'Inter'; margin-bottom:40px;">Follow the red target with your eyes. Click each point to register.</p>
        <div id="calib-target" class="calib-dot" style="display:none;"></div>
    </div>

    <div id="phantom-overlay">
        <div class="phantom-text">PHANTOM LINK ACTIVATED</div>
        <div class="phantom-sub" style="margin-bottom:20px">Scan this QR Code with your mobile device to use it as a high-fidelity gaze sensor.</div>
        <div id="qrcode-container"></div>
        <div class="phantom-sub" id="phantom-status">Waiting for connection...</div>
        <button class="btn stop" style="margin-top:20px" onclick="document.getElementById('phantom-overlay').style.display='none'">CANCEL</button>
    </div>

    <div id="sensor-ui">
        <div class="sensor-pulse"></div>
        <h2 style="font-family:'Rajdhani'; color:#fff; margin-top:30px;">SENSOR ACTIVE</h2>
        <p style="color:#888; font-family:'Inter';">Streaming biometric data to Host...</p>
        <p style="color:#444; font-size:12px; margin-top:20px;">DO NOT CLOSE THIS TAB</p>
    </div>

    <div id="env-warning">‚ö†Ô∏è POOR LIGHTING DETECTED</div>

    <div id="summary-overlay">
        <div class="summary-card">
            <div class="summary-title">SESSION ANALYTICS & HIGHLIGHTS</div>
            <div class="stat-grid">
                <div class="stat-item">
                    <div class="stat-val" id="sum-duration">00:00</div>
                    <div class="stat-label">SESSION DURATION</div>
                </div>
                <div class="stat-item">
                    <div class="stat-val" id="sum-stress" style="color:var(--accent-red)">0%</div>
                    <div class="stat-label">PEAK FRUSTRATION</div>
                </div>
                <div class="stat-item">
                    <div class="stat-val" id="sum-dwell">0s</div>
                    <div class="stat-label">AVG DWELL TIME (DEEP)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-val" id="sum-focus" style="color:var(--accent-purple)">0%</div>
                    <div class="stat-label">HIERARCHY SCORE</div>
                </div>
            </div>
            
            <div style="margin-top:20px;">
                <div style="font-family:var(--font-code); color:var(--text-dim); font-size:10px;">DIRECTOR'S HIGHLIGHTS (AUTO-GENERATED)</div>
                <div id="highlight-reel"></div>
            </div>

            <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:20px;">
                <button class="btn" onclick="document.getElementById('summary-overlay').style.display='none'">CLOSE</button>
                <button class="btn ai" onclick="ReportEngine.generate()">DOWNLOAD PDF</button>
            </div>
        </div>
    </div>

    <main>
        <div id="visual-column">
            <div id="screen-panel">
                <video id="screen-video" autoplay playsinline muted></video>
                <img id="mobile-sim-img" src="https://images.unsplash.com/photo-1481487484168-9b995ecc1679?q=80&w=2000&auto=format&fit=crop">
                
                <div id="dom-overlay"></div>
                <div id="recenter-target" onclick="Sentinel.recalibrate()" title="Look here and click to fix drift">üéØ</div>
                <canvas id="heatmap-canvas"></canvas>
                
                <div id="face-pip">
                    <video id="face-video" autoplay playsinline muted></video>
                    <canvas id="face-overlay"></canvas>
                </div>
            </div>

            <div id="controls">
                <button class="btn primary" id="btn-init" onclick="Sentinel.init()">
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M5 3l14 9-14 9V3z"/></svg>
                    INITIALIZE
                </button>
                
                <button class="btn upload hidden" id="btn-upload" onclick="document.getElementById('file-upload').click()">
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>
                    UPLOAD UI
                </button>
                
                <button class="btn replay hidden" id="btn-load" onclick="document.getElementById('json-upload').click()">
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                    LOAD REPLAY
                </button>

                <button class="btn replay hidden" id="btn-phantom" onclick="PhantomLink.generateHost()">
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M4 17l6-6-6-6M12 19h8a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-8"/></svg>
                    LINK MOBILE
                </button>

                <button class="btn tool hidden" id="btn-light" onclick="Zenith.toggleLight()">
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
                    LIGHT
                </button>

                <button class="btn ai hidden" id="btn-report" onclick="ReportEngine.generate()">
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                    REPORT
                </button>

                <button class="btn hidden" id="btn-data" onclick="TelemetryDeck.export()">
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>
                    JSON
                </button>

                <button class="btn stop hidden" id="btn-stop" onclick="Sentinel.terminate()">STOP</button>
            </div>
        </div>

        <aside>
            <div id="ai-console">
                <div class="console-header">
                    <span>ARCHITECT_AI_CORE // V20.0</span>
                    <span style="color:var(--accent-green)">ONLINE</span>
                </div>
                <div id="ai-output">Waiting for biometric triggers...<span class="ai-cursor"></span></div>
            </div>

            <div id="metrics-panel">
                <div class="metric-row">
                    <span>CONFUSION INDEX</span>
                    <div class="bar-bg"><div class="bar-fill" id="bar-conf" style="background:var(--accent-orange)"></div></div>
                </div>
                <div class="metric-row">
                    <span>FRUSTRATION INDEX</span>
                    <div class="bar-bg"><div class="bar-fill" id="bar-frust" style="background:var(--accent-red)"></div></div>
                </div>
                <div class="metric-row">
                    <span>VISUAL ATTENTION</span>
                    <div class="bar-bg"><div class="bar-fill" id="bar-gaze" style="background:var(--accent-purple)"></div></div>
                </div>
            </div>

            <div id="log-panel">
                <div class="panel-title">LIVE EVENT STREAM</div>
                <div id="log-feed">
                    </div>
            </div>

            <div id="snapshot-gallery">
                </div>
        </aside>
    </main>

    <input type="file" id="file-upload" accept="image/*" class="hidden" onchange="DOMSpy.handleUpload(this)">
    <input type="file" id="json-upload" accept=".json" class="hidden" onchange="ReplayEngine.load(this)">
    <canvas id="capture-canvas" class="proc"></canvas>
    <canvas id="crop-canvas" class="proc"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432244/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src='https://unpkg.com/tesseract.js@v2.1.0/dist/tesseract.min.js'></script>
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <script>
        /**
         * ==========================================================================
         * UX_SENTINEL MASTER KERNEL (V20.0 ZENITH EDITION)
         * PHASES 1-23 INTEGRATED | MAX ACCURACY + STABILIZATION
         * ==========================================================================
         */

        /* --- [CRASH GUARD] --- */
        window.onerror = function(msg, url, line) {
            if (msg.includes("function signature mismatch") || msg.includes("WASM")) {
                console.warn("Mobile WASM Crash Detected. Switching to Safe Mode.");
                if (typeof InputManager !== 'undefined') InputManager.enableMouseProxy();
                return true; 
            }
        };

        const Logger = {
            log(msg, type='') {
                const div = document.createElement('div');
                div.className = `log-entry ${type}`;
                div.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
                UI.logs.prepend(div);
            }
        };

        const STATE = {
            active: false,
            isMobile: false, 
            inputType: 'WEBCAM',
            metrics: { confusion: 0, frustration: 0, gazeX: 0.5, gazeY: 0.5 },
            lastTriggerTime: 0,
            snapshots: 0,
            gazeHistory: [],
            evidenceLog: [],
            telemetry: [], 
            startTime: 0,
            calibrated: false,
            calibData: { xMin: 1, xMax: 0, yMin: 1, yMax: 0 },
            eyePos: { x: 0.5, y: 0.5 },
            mode: 'LIVE',
            dwellMap: {}, 
            highlights: [],
            // PHASE 21 DATA
            gyroOffset: { x: 0, y: 0 } 
        };

        const UI = {
            screen: document.getElementById('screen-video'),
            simImg: document.getElementById('mobile-sim-img'),
            domOverlay: document.getElementById('dom-overlay'),
            heatmapCtx: document.getElementById('heatmap-canvas').getContext('2d'),
            face: document.getElementById('face-video'),
            faceCtx: document.getElementById('face-overlay').getContext('2d'),
            aiOutput: document.getElementById('ai-output'),
            logs: document.getElementById('log-feed'),
            gallery: document.getElementById('snapshot-gallery'),
            status: document.getElementById('sys-status'),
            btnInit: document.getElementById('btn-init'),
            btnStop: document.getElementById('btn-stop'),
            btnReport: document.getElementById('btn-report'),
            btnUpload: document.getElementById('btn-upload'),
            btnData: document.getElementById('btn-data'),
            btnLoad: document.getElementById('btn-load'),
            btnPhantom: document.getElementById('btn-phantom'),
            btnLight: document.getElementById('btn-light'), // Phase 22
            barConf: document.getElementById('bar-conf'),
            barFrust: document.getElementById('bar-frust'),
            barGaze: document.getElementById('bar-gaze'),
            calibOverlay: document.getElementById('calib-overlay'),
            calibTarget: document.getElementById('calib-target'),
            summaryOverlay: document.getElementById('summary-overlay'),
            recenterTarget: document.getElementById('recenter-target'),
            highlightReel: document.getElementById('highlight-reel'),
            phantomOverlay: document.getElementById('phantom-overlay'),
            qrContainer: document.getElementById('qrcode-container'),
            sensorUI: document.getElementById('sensor-ui'),
            envWarning: document.getElementById('env-warning'),
            ringLight: document.getElementById('ring-light') // Phase 22
        };

        /* --- [PHASE 21 & 22: ZENITH FEATURES (GYRO + LIGHT)] --- */
        class ZenithFeatures {
            constructor() {
                this.lightActive = false;
                this.initGyro();
            }

            // Phase 22: Flashlight/Screen Brightness
            toggleLight() {
                this.lightActive = !this.lightActive;
                if (this.lightActive) {
                    UI.ringLight.style.display = 'block';
                    UI.btnLight.innerText = "LIGHT: ON";
                    Logger.log("Ring Light Activated.", "sys");
                } else {
                    UI.ringLight.style.display = 'none';
                    UI.btnLight.innerText = "LIGHT";
                }
            }

            // Phase 21: Gyroscopic Stabilization
            initGyro() {
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        if (!STATE.active) return;
                        // Calculate slight offsets based on tilt
                        // beta = front/back, gamma = left/right
                        // We use small factors to just dampen jitter, not steer
                        STATE.gyroOffset.x = (e.gamma || 0) * 0.005; 
                        STATE.gyroOffset.y = (e.beta || 0) * 0.005; 
                    });
                }
            }
        }
        const Zenith = new ZenithFeatures();

        /* --- [PHASE 20: ENVIRONMENT MONITOR] --- */
        class EnvironmentMonitor {
            constructor() {
                this.lastCheck = 0;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.canvas.width = 100;
                this.canvas.height = 100;
            }

            check(videoElement, faceMesh) {
                const now = Date.now();
                if (now - this.lastCheck < 2000) return; // Check every 2s to save CPU
                this.lastCheck = now;

                if (!videoElement || videoElement.videoWidth === 0) return;

                // 1. Lighting Check
                this.ctx.drawImage(videoElement, 0, 0, 100, 100);
                const frame = this.ctx.getImageData(0, 0, 100, 100).data;
                let brightness = 0;
                for (let i = 0; i < frame.length; i += 4) {
                    brightness += (frame[i] + frame[i+1] + frame[i+2]) / 3;
                }
                brightness /= (frame.length / 4);

                // 2. Distance Check (Face Height)
                // 10=Top, 152=Chin
                let faceHeight = 0.5; // Default safe
                if (faceMesh) {
                    faceHeight = Math.abs(faceMesh[10].y - faceMesh[152].y);
                }

                this.updateUI(brightness, faceHeight);
            }

            updateUI(b, h) {
                const warning = UI.envWarning;
                if (b < 40) {
                    warning.innerText = "‚ö†Ô∏è LOW LIGHT: DATA UNRELIABLE";
                    warning.style.display = 'block';
                } else if (h < 0.2) {
                    warning.innerText = "‚ö†Ô∏è TOO FAR: MOVE CLOSER";
                    warning.style.display = 'block';
                } else if (h > 0.8) {
                    warning.innerText = "‚ö†Ô∏è TOO CLOSE: MOVE BACK";
                    warning.style.display = 'block';
                } else {
                    warning.style.display = 'none';
                }
            }
        }
        const EnvMonitor = new EnvironmentMonitor();

        /* --- [PHASE 19: SACCADE FILTER] --- */
        class SaccadeFilter {
            constructor() {
                this.lastX = 0.5; this.lastY = 0.5;
                this.lastTime = 0;
                this.threshold = 0.3; // Velocity threshold (0.3 screen units / sec)
                this.isFixating = false;
            }
            check(newX, newY) {
                const now = Date.now();
                const dt = (now - this.lastTime) / 1000; // seconds
                if (dt === 0) return this.isFixating;

                const dist = Math.sqrt(Math.pow(newX - this.lastX, 2) + Math.pow(newY - this.lastY, 2));
                const velocity = dist / dt;

                this.lastX = newX; this.lastY = newY; this.lastTime = now;

                // Logic: If moving too fast, it's a saccade (blind jump).
                // If slow, it's a fixation (processing info).
                this.isFixating = velocity < this.threshold;
                return this.isFixating;
            }
        }
        const SaccadeEngine = new SaccadeFilter();

        /* --- [PHASE 17: KALMAN FILTER] --- */
        class KalmanFilter {
            constructor(R = 1, Q = 1, A = 1, B = 0, C = 1) {
                this.R = R; this.Q = Q; this.A = A; this.B = B; this.C = C;
                this.cov = NaN; this.x = NaN;
            }
            filter(measurement) {
                if (isNaN(this.x)) {
                    this.x = (1 / this.C) * measurement;
                    this.cov = (1 / this.C) * this.R * (1 / this.C);
                } else {
                    const predX = (this.A * this.x) + (this.B * 0);
                    const predCov = ((this.A * this.cov) * this.A) + this.Q;
                    const K = predCov * this.C * (1 / ((this.C * predCov * this.C) + this.R));
                    this.x = predX + K * (measurement - (this.C * predX));
                    this.cov = predCov - (K * this.C * predCov);
                }
                return this.x;
            }
        }

        /* --- [PHASE 16: PHANTOM LINK] --- */
        class PhantomLinkSystem {
            constructor() { this.peer = null; this.conn = null; this.isHost = false; }
            generateHost() {
                this.isHost = true;
                const id = `UXS_${Math.floor(Math.random()*10000)}`;
                this.peer = new Peer(id);
                this.peer.on('open', (id) => {
                    UI.phantomOverlay.style.display = 'flex';
                    UI.qrContainer.innerHTML = '';
                    const url = `${window.location.href.split('?')[0]}?sensor=true&host=${id}`;
                    new QRCode(UI.qrContainer, url);
                    Logger.log(`Phantom Host Created: ${id}`, "sys");
                });
                this.peer.on('connection', (conn) => {
                    this.conn = conn;
                    UI.phantomOverlay.style.display = 'none';
                    UI.status.innerText = "SENSOR CONNECTED";
                    UI.status.classList.add('phantom');
                    UI.btnPhantom.classList.add('hidden');
                    Logger.log("Mobile Sensor Linked via WebRTC.", "sys");
                    STATE.inputType = 'REMOTE_SENSOR';
                    conn.on('data', (data) => { this.handleRemoteData(data); });
                });
            }
            initSensorMode(hostId) {
                this.peer = new Peer();
                UI.sensorUI.style.display = 'flex';
                document.querySelector('main').style.display = 'none'; 
                this.peer.on('open', () => {
                    this.conn = this.peer.connect(hostId);
                    this.conn.on('open', () => {
                        Logger.log("Connected to Host.", "sys");
                        Sentinel.initFaceMeshOnly();
                    });
                });
            }
            streamToHost(metrics) { if (this.conn && this.conn.open) this.conn.send(metrics); }
            handleRemoteData(metrics) {
                if (STATE.mode === 'REPLAY') return;
                STATE.metrics = metrics;
                
                // SACCADE CHECK FOR REMOTE DATA
                if (SaccadeEngine.check(metrics.gazeX, metrics.gazeY)) {
                    TelemetryDeck.record(STATE.metrics);
                    Sentinel.drawHeatmap(STATE.metrics.gazeX, STATE.metrics.gazeY);
                }
                
                const element = DOMSpy.scan(STATE.metrics.gazeX, STATE.metrics.gazeY);
                DwellTracker.track(element);
                Sentinel.updateBars(STATE.metrics);
                
                if (STATE.metrics.frustration > 70 && (Date.now() - STATE.lastTriggerTime > 3000)) {
                    Sentinel.trigger("STRESS_EVENT", STATE.metrics, element);
                    STATE.lastTriggerTime = Date.now();
                }
            }
        }
        const PhantomLink = new PhantomLinkSystem();

        /* --- [PHASE 15: DEEP METRICS & DIRECTOR] --- */
        class DwellMonitor {
            constructor() { this.currentElement = null; this.enterTime = 0; }
            track(domId) {
                if (!STATE.active || STATE.mode === 'REPLAY') return;
                const now = Date.now();
                if (domId !== this.currentElement) {
                    if (this.currentElement) {
                        const duration = now - this.enterTime;
                        if (!STATE.dwellMap[this.currentElement]) STATE.dwellMap[this.currentElement] = 0;
                        STATE.dwellMap[this.currentElement] += duration;
                    }
                    this.currentElement = domId; this.enterTime = now;
                }
            }
        }
        const DwellTracker = new DwellMonitor();

        class DirectorEngine {
            constructor() { this.isRecordingEvent = false; this.eventStartTime = 0; }
            monitor(metrics) {
                if (!STATE.active || STATE.mode === 'REPLAY') return;
                const isStress = metrics.frustration > 70;
                if (isStress && !this.isRecordingEvent) {
                    this.isRecordingEvent = true; this.eventStartTime = Date.now() - STATE.startTime;
                } else if (!isStress && this.isRecordingEvent) {
                    this.isRecordingEvent = false;
                    const duration = (Date.now() - STATE.startTime) - this.eventStartTime;
                    if (duration > 1000) {
                        STATE.highlights.push({ start: this.eventStartTime, end: this.eventStartTime + duration, reason: "Frustration" });
                        Logger.log("Director: Highlight captured.", "ai");
                    }
                }
            }
        }
        const Director = new DirectorEngine();

        class InputManager {
            static enableMouseProxy() {
                STATE.inputType = 'MOUSE_PROXY';
                Logger.log("Webcam Failed. Switched to Mouse Proxy Mode.", "sys");
                UI.status.innerText = "MOUSE MODE (FALLBACK)"; UI.status.classList.add('fallback');
                document.addEventListener('mousemove', (e) => {
                    if (!STATE.active || STATE.inputType !== 'MOUSE_PROXY') return;
                    const rect = UI.screen.parentElement.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / rect.width;
                    const y = (e.clientY - rect.top) / rect.height;
                    STATE.metrics = { gazeX: Math.max(0, Math.min(1, x)), gazeY: Math.max(0, Math.min(1, y)), confusion: 0, frustration: 0 };
                    
                    // Mouse always counts as fixation
                    Sentinel.drawHeatmap(STATE.metrics.gazeX, STATE.metrics.gazeY);
                    TelemetryDeck.record(STATE.metrics);
                });
            }
        }

        class LivingGrid {
            constructor() {
                document.getElementById('screen-panel').addEventListener('click', (e) => {
                    if (!STATE.active || !STATE.calibrated) return;
                    const rect = e.target.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / rect.width;
                    const clickY = (e.clientY - rect.top) / rect.height;
                    Gaze.recalibrateCenter(STATE.eyePos.x, STATE.eyePos.y, clickX, clickY);
                    Logger.log("Auto-Calibrated on Interaction.", "sys");
                });
            }
        }
        const AutoCalib = new LivingGrid();

        class SessionManager {
            static save(calib) { localStorage.setItem('UXS_CALIB', JSON.stringify(calib)); }
            static load() {
                const saved = localStorage.getItem('UXS_CALIB');
                if (saved) { STATE.calibData = JSON.parse(saved); STATE.calibrated = true; Gaze.setCalibration(STATE.calibData); Logger.log("Restored session.", "sys"); return true; }
                return false;
            }
        }

        class ReplaySystem {
            constructor() { this.data = null; this.frameIdx = 0; }
            load(input) {
                const file = input.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => { try { this.data = JSON.parse(e.target.result); this.startReplay(); } catch(err) { alert("Invalid JSON"); } };
                reader.readAsText(file);
            }
            startReplay() {
                if (!this.data) return;
                STATE.mode = 'REPLAY'; STATE.active = true; this.frameIdx = 0;
                UI.status.innerText = "SYSTEM: REPLAYING"; UI.status.classList.add('replay');
                UI.btnInit.classList.add('hidden'); UI.btnStop.classList.remove('hidden');
                if(this.data.highlights) STATE.highlights = this.data.highlights;
                AnalyticsEngine.populateHighlights();
                Logger.log(`Loaded: ${this.data.session_id}`, "sys");
                this.loop();
            }
            jumpTo(timeMs) {
                if (!this.data) return;
                const targetT = this.data.frames[0].t + timeMs;
                const idx = this.data.frames.findIndex(f => f.t >= targetT);
                if (idx !== -1) this.frameIdx = idx;
            }
            loop() {
                if (!STATE.active || STATE.mode !== 'REPLAY') return;
                const frame = this.data.frames[this.frameIdx];
                if (!frame) { this.finish(); return; }
                STATE.metrics = { gazeX: frame.g[0], gazeY: frame.g[1], confusion: frame.e[0], frustration: frame.e[1] };
                Sentinel.drawHeatmap(STATE.metrics.gazeX, STATE.metrics.gazeY);
                Sentinel.updateBars(STATE.metrics);
                this.frameIdx++;
                requestAnimationFrame(() => this.loop());
            }
            finish() { Logger.log("Replay End.", "sys"); Sentinel.terminate(); }
        }
        const ReplayEngine = new ReplaySystem();

        class AnalyticsEngine {
            static compute() {
                const duration = (Date.now() - STATE.startTime) / 1000;
                let maxStress = 0; let totalDwell = 0;
                STATE.telemetry.forEach(f => { if(f.e[1] > maxStress) maxStress = f.e[1]; });
                for (const [id, time] of Object.entries(STATE.dwellMap)) totalDwell += time;
                const avgDwell = Object.keys(STATE.dwellMap).length > 0 ? totalDwell / Object.keys(STATE.dwellMap).length : 0;
                
                document.getElementById('sum-duration').innerText = new Date(duration * 1000).toISOString().substr(14, 5);
                document.getElementById('sum-stress').innerText = maxStress + "%";
                document.getElementById('sum-dwell').innerText = (avgDwell/1000).toFixed(1) + "s";
                document.getElementById('sum-focus').innerText = (Math.min(100, Math.floor((totalDwell / (duration*1000)) * 100)) || 0) + "%";
                this.populateHighlights();
                UI.summaryOverlay.style.display = 'flex';
            }
            static populateHighlights() {
                UI.highlightReel.innerHTML = '';
                if (STATE.highlights.length === 0) UI.highlightReel.innerHTML = '<span style="color:#666; font-size:10px;">No events.</span>';
                STATE.highlights.forEach((h, i) => {
                    const btn = document.createElement('div'); btn.className = 'highlight-chip';
                    btn.innerText = `#${i+1} ${h.reason}`;
                    btn.onclick = () => { if (STATE.mode === 'REPLAY') ReplayEngine.jumpTo(h.start); else alert("Load Replay First"); };
                    UI.highlightReel.appendChild(btn);
                });
            }
        }

        class ArchitectEngine {
            constructor() {
                this.typingTimer = null;
                this.knowledgeBase = {
                    'BUTTON': ["Law of Proximity issue.", "Fitts's Law violation."],
                    'NAVIGATION': ["Miller's Law violation.", "Inconsistent Iconography."],
                    'TEXT_NODE': ["Accessibility Risk: Too dense.", "Line length > 60ch."],
                    'INPUT': ["Interaction Cost High.", "Missing Validation."]
                };
            }
            analyze(evidence) {
                let cat = 'TEXT_NODE'; 
                if (evidence.domId && evidence.domId.includes("BUTTON")) cat = 'BUTTON';
                else if (evidence.domId && evidence.domId.includes("NAV")) cat = 'NAVIGATION';
                const rules = this.knowledgeBase[cat];
                const rule = rules[Math.floor(Math.random() * rules.length)];
                const insight = evidence.stress > 80 ? `CRITICAL: ${rule}` : `NOTE: ${rule}`;
                this.typewriterEffect(insight);
                return insight;
            }
            typewriterEffect(text) {
                if (this.typingTimer) clearInterval(this.typingTimer);
                UI.aiOutput.innerHTML = ""; let i = 0;
                this.typingTimer = setInterval(() => {
                    UI.aiOutput.innerHTML += text.charAt(i); i++;
                    if (i >= text.length) clearInterval(this.typingTimer);
                    UI.aiOutput.scrollTop = UI.aiOutput.scrollHeight;
                }, 20);
                Logger.log("Architect: Insight generated.", "ai");
            }
        }
        const Architect = new ArchitectEngine();

        /* --- [PHASE 23: DEEP CLEAN TELEMETRY] --- */
        class TelemetryDeck {
            static record(frame) {
                if (!STATE.active || STATE.mode === 'REPLAY') return;
                if (!frame || typeof frame.gazeX !== 'number') return;
                if (STATE.telemetry.length > 5000) STATE.telemetry.shift();
                STATE.telemetry.push({ t: Date.now(), g: [parseFloat(frame.gazeX.toFixed(3)), parseFloat(frame.gazeY.toFixed(3))], e: [frame.confusion|0, frame.frustration|0] });
            }
            static refineData(frames) {
                // Simple moving average smoothing post-process
                const smoothed = [];
                const windowSize = 5;
                for (let i = 0; i < frames.length; i++) {
                    let sumX = 0, sumY = 0, count = 0;
                    for (let j = Math.max(0, i - windowSize); j <= Math.min(frames.length - 1, i + windowSize); j++) {
                        sumX += frames[j].g[0];
                        sumY += frames[j].g[1];
                        count++;
                    }
                    smoothed.push({
                        t: frames[i].t,
                        g: [parseFloat((sumX / count).toFixed(3)), parseFloat((sumY / count).toFixed(3))],
                        e: frames[i].e
                    });
                }
                return smoothed;
            }
            static export() {
                if (STATE.telemetry.length === 0) return;
                Logger.log("Refining Data (Deep Clean)...", "ai");
                const cleanFrames = this.refineData(STATE.telemetry);
                
                const data = { 
                    session_id: `UXS_${Date.now()}`, 
                    duration_ms: cleanFrames.length*33, 
                    events: STATE.evidenceLog.length, 
                    frames: cleanFrames, // Use smoothed data
                    highlights: STATE.highlights 
                };
                const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify(data)], {type:"application/json"}));
                a.download = `UX_SESSION_${Date.now()}.json`; a.click();
            }
        }

        class DOMSpyEngine {
            constructor() { this.virtualMap = [{id:'NAV',x:0,y:0,w:1,h:0.1},{id:'HERO',x:0,y:0.1,w:1,h:0.4},{id:'CTA',x:0.1,y:0.7,w:0.8,h:0.1}]; }
            handleUpload(input) {
                if (input.files[0]) {
                    const r = new FileReader();
                    r.onload = (e) => { UI.simImg.src = e.target.result; this.scanAndMap(e.target.result); };
                    r.readAsDataURL(input.files[0]);
                }
            }
            async scanAndMap(src) {
                if (!Reader.worker) await Reader.init();
                const { data } = await Reader.worker.recognize(src);
                const img = new Image(); img.src = src; await img.decode();
                this.virtualMap = data.words.map(w => ({ id: w.text.toUpperCase(), x: w.bbox.x0/img.width, y: w.bbox.y0/img.height, w: (w.bbox.x1-w.bbox.x0)/img.width, h: (w.bbox.y1-w.bbox.y0)/img.height, type: 'TEXT' }));
                Logger.log(`DOM Rebuilt: ${this.virtualMap.length} nodes.`, "dom");
            }
            scan(x, y) {
                const el = this.virtualMap.find(e => x >= e.x && x <= e.x+e.w && y >= e.y && y <= e.y+e.h);
                if (el) { UI.domOverlay.innerHTML = `<div style="position:absolute;left:${el.x*100}%;top:${el.y*100}%;width:${el.w*100}%;height:${el.h*100}%;border:2px dashed cyan;"></div>`; return el.id; }
                UI.domOverlay.innerHTML = ''; return null;
            }
        }
        const DOMSpy = new DOMSpyEngine();

        class CalibrationEngine {
            constructor() { this.points = [{x:10,y:10}, {x:50,y:10}, {x:90,y:10}, {x:10,y:50}, {x:50,y:50}, {x:90,y:50}, {x:10,y:90}, {x:50,y:90}, {x:90,y:90}]; this.idx = 0; }
            start() { UI.calibOverlay.style.display = 'flex'; UI.status.innerText = "CALIBRATING"; UI.status.classList.add('calib'); this.next(); }
            next() {
                if (this.idx >= this.points.length) { this.finish(); return; }
                const p = this.points[this.idx];
                UI.calibTarget.style.left = p.x + "%"; UI.calibTarget.style.top = p.y + "%"; UI.calibTarget.style.display = 'block';
                UI.calibTarget.onclick = () => {
                    const eye = STATE.eyePos;
                    if (eye.x < STATE.calibData.xMin) STATE.calibData.xMin = eye.x;
                    if (eye.x > STATE.calibData.xMax) STATE.calibData.xMax = eye.x;
                    if (eye.y < STATE.calibData.yMin) STATE.calibData.yMin = eye.y;
                    if (eye.y > STATE.calibData.yMax) STATE.calibData.yMax = eye.y;
                    this.idx++; this.next();
                };
            }
            finish() {
                UI.calibOverlay.style.display = 'none'; STATE.calibrated = true;
                UI.status.classList.remove('calib'); UI.status.innerText = "ACTIVE"; UI.status.classList.add('active');
                Logger.log("Calibration Complete.", "calib");
                Gaze.setCalibration(STATE.calibData);
                SessionManager.save(STATE.calibData); 
                UI.recenterTarget.style.display = 'flex'; 
            }
        }
        const Calibrator = new CalibrationEngine();

        class OCREngine {
            constructor() { this.worker = null; this.init(); }
            async init() {
                try {
                    this.worker = Tesseract.createWorker();
                    await this.worker.load(); await this.worker.loadLanguage('eng'); await this.worker.initialize('eng');
                    Logger.log("OCR Engine Online.", "ocr");
                } catch(e) { Logger.log("OCR Init Failed.", "error"); }
            }
            async scan(imgData) {
                if (!this.worker) return "OCR_WAIT";
                UI.status.innerText = "READING..."; UI.status.classList.add('ocr');
                const { data: { text } } = await this.worker.recognize(imgData);
                UI.status.classList.remove('ocr'); UI.status.innerText = "ACTIVE";
                return text.replace(/\n/g, " ").substring(0, 50) || "NO_TEXT";
            }
        }
        const Reader = new OCREngine();

        const MathUtils = { lerp: (start, end, amt) => (1 - amt) * start + amt * end };

        /* --- [UPDATED GAZE ENGINE WITH IRIS & KALMAN] --- */
        class GazeEngine {
            constructor() { 
                this.calib = {xOff:0.4, yOff:0.4, xScale:5, yScale:4}; 
                this.kalmanX = new KalmanFilter(0.01, 2, 1, 0, 1);
                this.kalmanY = new KalmanFilter(0.01, 2, 1, 0, 1);
            }
            setCalibration(d) { this.calib.xOff=d.xMin; this.calib.yOff=d.yMin; this.calib.xScale=1/(d.xMax-d.xMin); this.calib.yScale=1/(d.yMax-d.yMin); }
            recalibrateCenter(ex, ey, tx=0.5, ty=0.5) { this.calib.xOff = ex - (tx/this.calib.xScale); this.calib.yOff = ey - (ty/this.calib.yScale); }
            calculate(mesh) {
                // PHASE 18: IRIS GEOMETRY
                const irisL = mesh[468]; const irisR = mesh[473];
                const avgIrisX = (irisL.x + irisR.x) / 2;
                const avgIrisY = (irisL.y + irisR.y) / 2;
                
                STATE.eyePos = {x: avgIrisX, y: avgIrisY}; 

                let gx = (avgIrisX - this.calib.xOff) * this.calib.xScale; 
                let gy = (avgIrisY - this.calib.yOff) * this.calib.yScale;
                
                // PHASE 21: GYRO STABILIZATION
                gx -= STATE.gyroOffset.x;
                gy -= STATE.gyroOffset.y;

                // PHASE 17: KALMAN
                const smoothX = this.kalmanX.filter(gx);
                const smoothY = this.kalmanY.filter(gy);
                
                return { x: Math.max(0,Math.min(1,smoothX)), y: Math.max(0,Math.min(1,smoothY)) };
            }
        }
        const Gaze = new GazeEngine();

        const Engine = {
            analyze(mesh) {
                const w = Math.hypot(mesh[454].x - mesh[234].x, mesh[454].y - mesh[234].y);
                const b = Math.hypot(mesh[107].x - mesh[336].x, mesh[107].y - mesh[336].y) / w;
                return { frustration: b < 0.6 ? (0.6-b)*300 : 0, confusion: 0 };
            }
        };

        const Sentinel = {
            async init() {
                const params = new URLSearchParams(window.location.search);
                if (params.get('sensor')) { PhantomLink.initSensorMode(params.get('host')); return; }

                Logger.log("Initializing Zenith Core...", "sys");
                STATE.startTime = Date.now();
                UI.btnPhantom.classList.remove('hidden');
                UI.btnLight.classList.remove('hidden'); // Show Light Button

                try {
                    STATE.cameraStream = await navigator.mediaDevices.getUserMedia({video:{width:320,height:240}, audio:false});
                    UI.face.srcObject = STATE.cameraStream; await new Promise(r => UI.face.onloadedmetadata = r); UI.face.play();
                } catch(e) { InputManager.enableMouseProxy(); return; }

                try {
                    STATE.screenStream = await navigator.mediaDevices.getDisplayMedia({video:{cursor:"always"}, audio:false});
                    UI.screen.srcObject = STATE.screenStream; UI.screen.style.display = 'block';
                    STATE.screenStream.getVideoTracks()[0].onended = () => { this.terminate(); };
                } catch(e) { STATE.isMobile = true; UI.screen.style.display = 'none'; UI.simImg.style.display = 'block'; UI.btnUpload.classList.remove('hidden'); }

                this.initFaceMeshOnly();
            },

            initFaceMeshOnly() {
                const fm = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
                });
                fm.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5});
                
                const params = new URLSearchParams(window.location.search);
                if (params.get('sensor')) {
                    fm.onResults((res) => {
                        if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
                            const mesh = res.multiFaceLandmarks[0];
                            const emotion = Engine.analyze(mesh);
                            const gx = (mesh[468].x + mesh[473].x)/2; 
                            const gy = (mesh[10].y + mesh[152].y)/2;
                            PhantomLink.streamToHost({ gazeX: gx, gazeY: gy, frustration: emotion.frustration, confusion: emotion.confusion });
                        }
                    });
                } else {
                    fm.onResults(this.onResults);
                }

                const loop = async () => {
                    try { await fm.send({image: UI.face}); } catch(err) {}
                    requestAnimationFrame(loop);
                };
                
                if (!params.get('sensor')) {
                    STATE.active = true; 
                    UI.btnInit.classList.add('hidden'); UI.btnLoad.classList.add('hidden');
                    UI.btnStop.classList.remove('hidden'); UI.btnReport.classList.remove('hidden'); UI.btnData.classList.remove('hidden');
                    if (SessionManager.load()) UI.recenterTarget.style.display = 'flex';
                    else if (!STATE.isMobile) Calibrator.start();
                    else DOMSpy.scanAndMap(UI.simImg.src); 
                    this.resizeHeatmap(); window.addEventListener('resize', this.resizeHeatmap);
                }
                loop();
            },

            resizeHeatmap() { UI.heatmapCtx.canvas.width = UI.screen.parentElement.offsetWidth; UI.heatmapCtx.canvas.height = UI.screen.parentElement.offsetHeight; },
            recalibrate() { Gaze.recalibrateCenter(STATE.eyePos.x, STATE.eyePos.y); },
            onResults(res) {
                if (!STATE.active || STATE.mode === 'REPLAY' || STATE.inputType === 'REMOTE_SENSOR') return;
                UI.faceCtx.clearRect(0,0,UI.face.width,UI.face.height);
                if (!res.multiFaceLandmarks || res.multiFaceLandmarks.length === 0) return;
                const mesh = res.multiFaceLandmarks[0];
                const emo = Engine.analyze(mesh); const gaze = Gaze.calculate(mesh);
                STATE.metrics = { gazeX: gaze.x, gazeY: gaze.y, frustration: emo.frustration, confusion: emo.confusion };
                
                // Phase 20: Env Check
                EnvMonitor.check(UI.face, mesh);

                // PHASE 19: SACCADE FILTER LOGIC
                if (SaccadeEngine.check(gaze.x, gaze.y)) {
                    TelemetryDeck.record(STATE.metrics);
                    Sentinel.drawHeatmap(STATE.metrics.gazeX, STATE.metrics.gazeY);
                }
                
                Director.monitor(STATE.metrics);
                const el = DOMSpy.scan(STATE.metrics.gazeX, STATE.metrics.gazeY);
                DwellTracker.track(el);
                
                if (STATE.metrics.frustration > 70 && (Date.now()-STATE.lastTriggerTime > 3000)) { Sentinel.trigger("STRESS", STATE.metrics, el); STATE.lastTriggerTime = Date.now(); }
                
                Sentinel.updateBars(STATE.metrics);
                Sentinel.drawFace(mesh);
            },
            drawHeatmap(x, y) {
                const ctx = UI.heatmapCtx; const w = ctx.canvas.width; const h = ctx.canvas.height;
                STATE.gazeHistory.push({x:x*w, y:y*h, age:1}); if(STATE.gazeHistory.length>30) STATE.gazeHistory.shift();
                ctx.clearRect(0,0,w,h);
                STATE.gazeHistory.forEach(p => { p.age-=0.05; ctx.beginPath(); ctx.fillStyle=`rgba(163,113,247,${p.age*0.6})`; ctx.arc(p.x,p.y,40*p.age,0,Math.PI*2); ctx.fill(); });
            },
            drawFace(mesh) {
                const ctx = UI.faceCtx; ctx.strokeStyle="rgba(88,166,255,0.5)"; ctx.lineWidth=1; ctx.beginPath();
                const l = mesh[33]; const r = mesh[263]; ctx.moveTo(l.x*UI.face.width, l.y*UI.face.height); ctx.lineTo(r.x*UI.face.width, r.y*UI.face.height); ctx.stroke();
            },
            updateBars(m) { UI.barFrust.style.width=m.frustration+"%"; UI.barGaze.style.width="90%"; },
            trigger(t, m, el) { Logger.log(`TRIGGER: ${t}`, "alert"); },
            terminate() {
                STATE.active = false; UI.screen.style.display='none'; UI.simImg.style.display='none';
                UI.btnStop.classList.add('hidden'); UI.btnInit.classList.remove('hidden'); UI.btnLoad.classList.remove('hidden');
                UI.status.innerText="ENDED"; AnalyticsEngine.compute();
            }
        };
    </script>
</body>
</html>